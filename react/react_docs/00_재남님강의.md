# 알게된 단편적 지식들

## Quick Start [index](https://react-ko.dev/learn)

### js escape [index](https://react-ko.dev/learn#displaying-data)

```jsx
return <h1>{user.name}</h1>;
```

여기서 {} 이거를 JavaScript로 “이스케이프” 한다고 표현함

### conditional rendering [index](https://react-ko.dev/learn#conditional-rendering)

else 분기가 필요하지 않은 경우 더 짧은 논리 && 구문을 사용할 수도 있습니다:

```jsx
<div>{isLoggedIn && <AdminPanel />}</div>
```

주의 : JavaScript에서 && 연산자는 앞의 조건이 falsy 한 값이라면, 해당 객체를 반환하기 때문에 위의 예제에서는 0이 반환 되어 렌더링 되는 것입니다. 조건부 렌더링 - “&&의 왼쪽에 숫자를 넣지 마세요.”에서 다시 다룰 것입니다. MDN - falsy도 참고하세요.

### hook 사용하기 [index](https://react-ko.dev/learn#using-hooks)

훅은 일반 함수보다 더 제한적입니다. 컴포넌트(또는 다른 훅)의 최상위 레벨에서만 훅을 호출할 수 있습니다. 조건문이나 반복문에서 useState를 사용하고 싶다면, 대신 새로운 컴포넌트를 추출하고 그 컴포넌트에 작성하세요.

다른 훅에서 훅을 또 불러와서 사용하면 안됨.

### component간 정보 전달은 언제나 단방향 [index](https://react-ko.dev/learn#sharing-data-between-components)

컴포넌트에서 자식 컴포넌트로 데이터를 전달할 때는 props를 사용합니다. props는 부모 컴포넌트가 설정하고, 자식 컴포넌트에서는 읽기 전용으로만 사용할 수 있습니다. 그럼 자식에서 부모의 props를 변경하고 싶을 땐 어떡하나?

당연히 부모에서 해당 prop을 변경하는 함수도 같이 넘겨줘야 함!!

---

## tic-tac-toe [index](https://react-ko.dev/learn/tutorial-tic-tac-toe)

### state 끌어올리기 [index](https://react-ko.dev/learn/tutorial-tic-tac-toe#lifting-state-up)

여러 자식 컴포넌트에서 데이터를 수집하거나, 두 자식 컴포넌트가 서로 통신하도록 하려면, 부모 컴포넌트에서 공유 state를 대신 선언하세요. 부모 컴포넌트는 props를 통해 해당 state를 자식 컴포넌트에 다시 전달할 수 있습니다. 이렇게 하면 자식 컴포넌트가 서로 동기화되고 부모 컴포넌트와도 동기화되도록 유지할 수 있습니다.

React 컴포넌트를 리팩터링 할때, 부모 컴포넌트로 state를 끌어올리는 것이 일반적 방법입니다.

```jsx
export default function Board() {
  const [squares, setSquares] = useState(Array(9).fill(null));
  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} />
        <Square value={squares[1]} />
        <Square value={squares[2]} />
      </div>
      <div className="board-row">
        <Square value={squares[3]} />
        <Square value={squares[4]} />
        <Square value={squares[5]} />
      </div>
      <div className="board-row">
        <Square value={squares[6]} />
        <Square value={squares[7]} />
        <Square value={squares[8]} />
      </div>
    </>
  );
}
```

### js slice vs spread

```jsx
const squares = squares.slice();
```

```jsx
const squares = [...squares];
```

두 코드 모두 불변성을 유지하면서 배열을 복사한다. 같은 결과를 반환하지만, spread 연산자를 사용하는 것이 더 짧고 간단하다. 더 권장된다고 한다.
